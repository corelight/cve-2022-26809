module CVE_2022_26809;

export {
	redef enum Notice::Type += {
		ExploitAttempt,
		ExploitSuccess
	};
}

# Malicious byte strings
global big_endian = /..\x0c.\x00\x00\x00\x00/;
global big_endian_specific = /\x05\x00\x0c\x03\x00\x00\x00\x00/;

# Normal byte strings
global little_endian = /..\x0c.\x10\x00\x00\x00/;
global little_endian_specific = /\x05\x00\x0c\x03\x10\x00\x00\x00/;

event dce_rpc_request_stub(c: connection, fid: count, ctx_id: count,
    opnum: count, stub: string)
{
	# EfsRpcDecryptFileSrv
	if ( opnum == 5 ) {
		local v: vector of string;
		local ip = cat(c$id$orig_h);
		v += "\\";
		v += "\\";
		for ( char in cat(c$id$orig_h) ) {
			v += char;
		}
		local s = join_string_vec(v, "\x01");
		s = gsub(s, /\x01/, "\x00");
		if ( strstr(stub, s) > 0 ) {
			NOTICE([
			    $note=ExploitAttempt,
			    $msg=fmt("%s attempting exploit on %s", c$id$orig_h, c$id$resp_h),
			    $sub=fmt("Using opnum %d", opnum),
			    $identifier=cat(c$id$orig_h, c$id$resp_h)]);
		}
	}
}

# To make the weak regex more robust, go to a known offset for frag_length that
# should be equal to the size of the packet's data after finding the beginning
# of the DCERPC data, i.e., the first byte of the regex match.
function correct_frag_length(data: string, regex: pattern): bool
{
	local mres = match_pattern(data, regex);
	if ( ! mres$matched )
		return F;

	# mres$off - 1 is the offset to the start of the DCERPC section
	# 8 bytes until we hit frag length
	local start = mres$off - 1 + 8;
	local end = mres$off - 1 + 10;
	if ( end > |data| )
		return F;
	local frag_len_bytes = data[start:end];
	if ( |frag_len_bytes| == 0 )
		return F;

	local frag_len = bytestring_to_count(data[start:end]);

	return frag_len == |data| - mres$off + 1;
}

# Required for the underflow to occur.
function sec_addr_is_zero(data: string, regex: pattern): bool
{
	local mres = match_pattern(data, regex);
	if ( ! mres$matched )
		return F;

	# mres$off - 1 is the offset to the start of the DCERPC section
	# 24 bytes until we hit sec_addr_len.
	local start = mres$off - 1 + 24;
	local end = mres$off - 1 + 26;
	if ( end > |data| )
		return F;
	local sec_addr_len_bytes = data[start:end];
	if ( |sec_addr_len_bytes| == 0 )
		return F;

	local sec_addr_len = bytestring_to_count(data[start:end]);
	return sec_addr_len == 0;
}

# Exploit Bind ACKs are malformed, so we have to detect here.
event dce_rpc_message(c: connection, is_orig: bool, fid: count, ptype_id: count,
    ptype: DCE_RPC::PType)
{
	if ( ptype != DCE_RPC::BIND_ACK )
		return;
	local pkt = get_current_packet();
	if ( big_endian_specific in pkt$data && correct_frag_length(pkt$data,
	    big_endian_specific) && sec_addr_is_zero(pkt$data,
	    big_endian_specific) ) {
		NOTICE([
		    $note=ExploitSuccess,
		    $msg=fmt("%s exploited %s", c$id$orig_h, c$id$resp_h),
		    $sub="Found via big_endian_specific (in dce_rpc_message)",
		    $identifier=cat(c$id$orig_h, c$id$resp_h, "big_endian_specific")]);
	}
	if ( big_endian in pkt$data && correct_frag_length(pkt$data, big_endian) &&
	    sec_addr_is_zero(pkt$data, big_endian) ) {
		NOTICE([
		    $note=ExploitSuccess,
		    $msg=fmt("%s exploited %s", c$id$orig_h, c$id$resp_h),
		    $sub="Found via big_endian (in dce_rpc_message)",
		    $identifier=cat(c$id$orig_h, c$id$resp_h, "big_endian")]);
	}
}
